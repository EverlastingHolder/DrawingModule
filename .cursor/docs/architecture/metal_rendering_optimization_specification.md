# Спецификация оптимизации рендеринга Metal

**Статус**: ✅ ЧЕРНОВИК (Фаза закалки: Imageblocks и Smudge)
**Версия**: 1.0 (2026-02-04)

## 1. Оптимизация SRAM и Imageblock

### 1.1 Проблема размера тайла
Наш логический размер тайла составляет **256x256** в формате **RGBA16Float**.
*   Память на тайл: $256 \times 256 \times 8 \text{ байт} = 512 \text{ КБ}$.
*   **Аппаратное ограничение**: GPU Apple Silicon используют встроенную память SRAM (Imageblocks) для ускорения смешивания (blending) и многопроходного рендеринга. Однако объем памяти Imageblock на один аппаратный тайл ограничен (обычно 16–32 КБ для шейдеров с высокой загрузкой ядер).
*   **Spilling (вытеснение)**: Попытка обработать весь тайл 512 КБ за один проход приведет к вытеснению данных в VRAM, что резко снизит производительность и увеличит нагрузку на пропускную способность памяти.

### 1.2 Tile Shaders и Sub-Tiling (подтайлинг)
Для эффективного использования SRAM мы внедряем **Sub-Tiling**, используя Metal **Tile Shaders**.

1.  **Логический тайл (256x256)**: Единица нашей разреженной текстуры и системы Undo.
2.  **Аппаратный тайл (32x32)**: Единица выполнения на GPU.
    *   32x32 RGBA16Float = **8 КБ**.
    *   Это значение комфортно умещается в SRAM Imageblock, позволяя хранить несколько слоев или промежуточных буферов прямо на чипе.

**Рабочий процесс**:
*   **Фаза A (Загрузка)**: Tile Shader (или проход рендеринга с действием `load`) загружает данные из `MTLSparseTexture` в Imageblock.
*   **Фаза B (Вычисления/Смешивание)**: Все операции смешивания и размазывания (smudge) для области 32x32 происходят внутри SRAM.
*   **Фаза C (Сохранение)**: Финальный результат записывается обратно на физическую страницу `MTLSparseTexture` с использованием действия `store`.

### 1.3 Детали реализации на MSL
```cpp
struct ImageblockData {
    // Данные аппаратного тайла 32x32
    half4 color [[imageblock_data]];
};

kernel void tile_composite(
    imageblock<ImageblockData, imageblock_layout_explicit> block,
    ushort2 local_id [[thread_index_in_threadgroup]],
    ushort2 tile_id [[tile_id]]) 
{
    // Доступ к локальной памяти аппаратного тайла
    half4 current_color = block.data(local_id).color;
    
    // ... логика смешивания в SRAM ...
    
    block.data(local_id).color = blended_color;
}
```

---

## 2. Движок размазывания (Threadgroup Memory)

### 2.1 Обзор алгоритма
Движок размазывания (Smudge Engine) имитирует подхват краски с холста и её перенос. Чтобы достичь 120 FPS, мы минимизируем обращения к VRAM.

1.  **Фаза захвата**:
    *   Ядро определяет область под кистью.
    *   Пиксели холста загружаются в память `threadgroup`.
2.  **Фаза смешивания**:
    *   Сила «подхвата» кисти определяет, сколько цвета берется из памяти `threadgroup`.
    *   Цвет размазывания смешивается с цветом и альфой текущего отпечатка (stamp).
3.  **Фаза обновления**:
    *   Измененные цвета записываются обратно в Imageblock/VRAM.

### 2.2 Оптимизация давления на регистры (Register Pressure)
Чтобы поддерживать **120 FPS**, мы должны использовать не более **32 регистров** на поток.
*   **Half-Precision (половинная точность)**: Используйте `half` для всех вычислений цвета.
*   **Threadgroup Memory**: Перенос промежуточных выборок цвета в память `threadgroup` снижает количество активных регистров, необходимых для выборки.
*   **Безветвистая математика**: Используйте `clamp`, `step` и `mix` вместо `if/else`.

### 2.3 Структура памяти
```cpp
kernel void smudge_kernel(
    texture2d<half, access::read_write> canvas [[texture(0)]],
    threadgroup half4* shared_pixels [[threadgroup(0)]],
    uint2 gid [[thread_id_in_grid]],
    ushort2 lid [[thread_index_in_threadgroup]]) 
{
    // 1. Загрузка в Threadgroup (объединенный доступ)
    shared_pixels[lid.y * 32 + lid.x] = canvas.read(gid);
    threadgroup_barrier(mem_flags::mem_threadgroup);
    
    // 2. Вычисление размазывания
    half4 picked_color = shared_pixels[lid.y * 32 + lid.x];
    // ... логика размазывания ...
    
    // 3. Запись обратно
    canvas.write(final_color, gid);
}
```

---

## 3. Синхронизация и закалка конвейера

### 3.1 Внутрикадровая синхронизация (MTLFence)
Мы используем `MTLFence` для синхронизации между различными энкодерами в рамках одного командного буфера.
*   **Сценарий**: Проход `Splatting` записывает данные в `AccumulationBuffer`. Вычислительное ядро `Smudge` должно прочитать этот буфер.
*   **Реализация**: 
    - `SplatEncoder` вызывает `updateFence:`.
    - `SmudgeEncoder` вызывает `waitForFence:`.
    - Это позволяет GPU перекрывать выполнение задач там, где это возможно, гарантируя при этом целостность данных.

### 3.2 Межкадровая синхронизация (MTLEvent)
Тройная буферизация используется для того, чтобы CPU и GPU работали одновременно без состояний гонки.

1.  **Работа CPU (Кадр N+2)**: Подготовка геометрии, обновление содержимого `MTLBuffer`.
2.  **Работа GPU (Кадр N)**: Выполнение команд для предыдущего кадра.
3.  **Синхронизация**: 
    - `MTLEvent` отслеживает завершение кадра N на GPU.
    - CPU ждет, пока `event.signalValue == N`, прежде чем повторно использовать буфер для кадра `N+3`.

### 3.3 Иерархия конвейера
*   **Тройная буферизация**: Применяется к `MTLBuffer` (геометрия) и `MTLResidencySet`.
*   **Фенсы (Fences)**: Применяются между стадиями отрисовки (Render) и вычислений (Compute) одного мазка.
*   **Барьеры (Barriers)**: Используются внутри вычислительных ядер (`threadgroup_barrier`) для эффектов размазывания/размытия.

---

## 4. Кастомные GPU-эффекты (Хуки)

Для обеспечения расширяемости системы вводится этап `CustomProcess`.

### 4.1 Интерфейс BrushEffect
Сторонние разработчики реализуют протокол `BrushEffect`:
```swift
public protocol BrushEffect: Sendable {
    var functionName: String { get }
    var resources: [MTLResource] { get }
    var argumentBuffer: MTLBuffer? { get }
    var effectTypeID: String { get }
}
```

### 4.2 Поток выполнения GPU Hook
1. **Splat Pass**: Отрисовка Mask в `Memoryless` текстуру.
2. **Custom Hook**: Вызов кастомного шейдера (Kernel или Tile Shader). 
   - Ввод: `AccumulationBuffer`, `BackBuffer`.
   - Вывод: Модифицированный `AccumulationBuffer`.
3. **Composite Pass**: Финальное наложение.

---

## 5. Кроссплатформенность: Стратегия Fallback

Поскольку Intel/AMD Mac используют архитектуру **IMR (Immediate Mode Rendering)**, они не поддерживают `Imageblocks`.

### Динамический выбор пайплайна:
* **Путь TBDR (Apple Silicon)**: Использует `imageblock` и `Tile Shaders`. Смешивание на чипе.
* **Путь IMR (Intel/AMD)**: 
  - `AccumulationBuffer` хранится в `MTLStorageModePrivate` (VRAM).
  - Каждый этап (Splat, Process, Composite) — это отдельный Render Pass с действиями Load/Store.
  - Это увеличивает нагрузку на пропускную способность, но сохраняет визуальную идентичность.

---

## 6. Целевые показатели производительности

| Метрика | Цель | Оптимизация |
| :--- | :--- | :--- |
| **Время кадра** | 8.33 мс (120 FPS) | Лимит регистров (32), использование SRAM |
| **Пропускная способность памяти** | < 20 ГБ/с | Imageblocks, текстуры Memoryless |
| **Заполняемость (Occupancy)** | > 85% | Минимизация размера памяти threadgroup на TG |
| **Количество регистров** | <= 32 | Точность `half`, упрощенная математика |
