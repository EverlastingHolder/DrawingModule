# Технический аудит архитектуры: Undo/Redo DrawEngine

**Дата:** 4 февраля 2026 г.  
**Роль:** Lead Validation Orchestrator  
**Объект:** `.cursor/docs/architecture/undo_redo_architecture_specification.md`

---

## Финальный статус: `APPROVED`

Архитектура Undo/Redo была успешно исправлена и прошла повторную верификацию. Все критические уязвимости (Write Amplification, GPU Bubbles, FIFO Races) устранены через внедрение Tile-centric снапшотов, Block Delta, Stroke Coalescing и Serial Commit Pipeline.

---

## 1. Критические риски (Issues) - [ИСПРАВЛЕНО]

### Issue 1: Катастрофический Write Amplification (WA) и IO-коллапс
*   **Проблема**: Использование "Region-centric snapshot" (регион 4x4 тайла) для записи каждого мазка.
*   **Мнение эксперта (Systems Engineer)**: При мазке в пару пикселей (160 байт) система записывает регион размером 8 МБ. Это создает Write Amplification в **52 428 раз**. При 1000 мазках в секунду поток данных достигает 8 ГБ/с, что физически невозможно сжать (LZ4) или записать на диск мобильного устройства.
*   **Доказательство**: Даже с блоковой дельтой (64x64) WA остается на уровне ~200x. Без жесткого коалесинга система упадет в `Backpressure`, блокируя UI.
*   **Рекомендация**: Внедрить обязательный **Stroke Coalescing** на уровне `UndoCoordinator` (объединение мелких мазков в одну транзакцию по времени — например, каждые 50-100 мс).

### Issue 2: GPU Pipeline Bubbles и бюджет кадра (120 FPS)
*   **Проблема**: Стратегия `Snapshot phase -> write phase` в одном Command Buffer.
*   **Мнение эксперта (Metal Specialist)**: Захват снапшота (32 МБ для среднего мазка) занимает ~1.5 мс. Поскольку `BlitEncoder` и `RenderEncoder` выполняются последовательно, это создает «пузырь» (stall), съедающий 18% бюджета кадра (8.33 мс).
*   **Доказательство**: На базовых чипах конкуренция за L2-кэш между копированием Undo и рендерингом кисти приведет к падению FPS ниже 120.
*   **Рекомендация**: Перейти от копирования регионов к **Tile-level dirty tracking**. Копировать только измененные тайлы (0.5 МБ вместо 32 МБ), что снизит нагрузку на VRAM в 64 раза.

### Issue 3: Гонки в Transaction Index при высокой частоте (1000 Гц)
*   **Проблема**: Реентерабельность акторов в Swift 6.
*   **Мнение эксперта (Systems Engineer)**: При интервале между мазками в 1 мс `UndoCoordinator` может начать новую транзакцию до того, как `HistoryStore` завершит `await` предыдущего коммита.
*   **Доказательство**: Без серийного исполнителя порядок записей в `Global Transaction Index` может нарушиться, что сделает историю Undo неконсистентной.
*   **Рекомендация**: Использовать `AsyncStream` или серийную очередь внутри `UndoCoordinator` для гарантированного FIFO-порядка финализации транзакций.

---

## 2. Архитектурный вердикт (Lead Architect)
Система спроектирована как чистый **Mediator**, что обеспечивает хорошую модульность (8/10). Однако `UndoCoordinator` находится в зоне риска превращения в God-object. Необходимо строго изолировать логику расчета "грязных областей" в `StrokeProcessor`, оставив координатору только управление жизненным циклом транзакций.

---

## 3. Финальные требования для реализации (Checklist):

- [x] **Реализовать Stroke Coalescing**: объединение событий ввода до формирования транзакции.
- [x] **Оптимизировать Snapshot**: захват только измененных тайлов (256x256), а не целых регионов 4x4.
- [x] **Гарантировать FIFO**: внедрить Serial Dispatcher для коммитов в `HistoryStore`.
- [x] **Подтвердить Block Delta**: WAL должен оперировать блоками 64x64 внутри тайла для минимизации Write Amplification.

---